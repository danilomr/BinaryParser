package syntactic;

import abstracttree.DictionaryNode;
import abstracttree.KeyValueNode;
import abstracttree.ListNode;
import abstracttree.Node;
import abstracttree.NumberNode;
import abstracttree.StringNode;

import java.util.Arrays;
import java.util.LinkedList;

import lexic.Token;
import lexic.Tokenizer;

/**
 * Class that will be used to perform the syntactic analysis of the binary JSON file.
 * This class will use the tokens generated by the tokenization and create the abstract tree. 
 * 
 * This class uses the naming set of rules defined by the description of the project.
 * 
 * The grammar used to parse the entries is the following:
 * 
 * 
 * 
 * 	dictionary : array_key_value ;
 * 
 * 	array_key_value : key_value | array_key_value;
 * 
 * 	key_value : key ':' value ;
 * 
 * 	key : NUMBER | STRING ;
 * 
 * 	value : NUMBER | STRING | array_value | dictionary ;
 * 
 * 	array_value : value | value ',' array_value ;
 * 
 * 
 * 
 * @author danilo.melo.rocha
 *
 */
public class Parser {
	
	private LinkedList<Token> tokens;
    private Token lookahead;
    private Node nodeTree;

    /**
     * The abstract tree generated by the syntactic analysis.
     * @return Node
     */
    public Node getNodeTree() {
        return this.nodeTree;
    }

    public Parser(String input) {
        byte[] b = input.getBytes();

        Tokenizer tokenizer = new Tokenizer();
        tokenizer.tokenize(b);

        this.tokens = (LinkedList<Token>) tokenizer.getTokens().clone();
        this.lookahead = this.tokens.getFirst();

        this.nodeTree = attemptParsing();
    }

    /**
     * The function that will attempt to parse the input String.
     * Usually, a JSON file is a collection, but regarding to the input samples, this function
     * will also accept int, String and list as JSON binary.   
     * @return Node
     */
    private Node attemptParsing() {
        Node node = null;
        int[] typesToAttemptParsing = { Token.DICTIONARY, Token.LIST, Token.STRING, Token.NUMBER };
        while (typesToAttemptParsing.length != 0) {
            switch (typesToAttemptParsing[0]) {
                case Token.NUMBER:
                    node = number();
                    if (this.lookahead.token == Token.EPSILON) {
                        //System.out.println("Successfully parsed an int.");
                    }
                    break;
                case Token.STRING:
                    node = string();
                    if (this.lookahead.token == Token.EPSILON) {
                        //System.out.println("Successfully parsed a string.");
                    }
                    break;
                case Token.LIST:
                    node = arrayValue();
                    if (this.lookahead.token == Token.EPSILON) {
                        //System.out.println("Successfully parsed an array.");
                    }
                    break;
                case Token.DICTIONARY:
                    node = dictionary();
                    if (this.lookahead.token == Token.EPSILON) {
                        //System.out.println("Successfully parsed a JSON Dictionary.");
                    }
                    break;
                default:
                    break;
            }
            typesToAttemptParsing = Arrays.copyOfRange(typesToAttemptParsing, 1, typesToAttemptParsing.length);
            if (this.lookahead.token == Token.EPSILON) {
                break;
            }
        }
        if (this.lookahead.token != Token.EPSILON) {
            System.out.println("Failed parsing.");
        }
        return node;
    }

    /**
     * Consumes the token that is being identified by the parsed.
     */
    private void nextToken() {
        tokens.pop();
        // at the end of input we return an epsilon token
        if (tokens.isEmpty()) {
            lookahead = new Token(Token.EPSILON, ""/*, -1*/);
        } else {
            lookahead = tokens.getFirst();
        }
    }

    /**
     * Parse the dictionary/JSON file.
     * dictionary -> array_key_value;
     * @return Node
     */
    private Node dictionary() {
        DictionaryNode node = null;
        if (this.lookahead.token == Token.DICTIONARY) {
            node = new DictionaryNode();
            nextToken();
            arrayKeyValue(node);
        } else {
            // EPSILON
        }
        return node;
    }

    /**
     * Parse a list of values.
     * // array_value -> value | value ',' array_value ;
     * @return Node
     */
    private Node arrayValue() {
        ListNode node = null;
        if (this.lookahead.token == Token.LIST) {
            node = new ListNode();
            nextToken();
            // the current token is the amount of values
            int amountOfValues = new Integer(this.lookahead.sequence);
            nextToken();
            do {
                Node nodeItem = value();
                node.addValue(nodeItem);
                amountOfValues--;
            } while(amountOfValues > 0);
        }
        return node;
    }

    /**
     * Iterate through a list of key-value child to a dictionary.
     * array_key_value -> key_value | array_key_value;
     * @param dictionary DictionaryNode
     */
    private void arrayKeyValue(DictionaryNode dictionary) {
        // the current token is the amount of key values
        int amountOfKeyValues = new Integer(this.lookahead.sequence);
        nextToken();
        do {
            Node item = keyValue();
            dictionary.addValue(item);
            amountOfKeyValues--;
        } while(amountOfKeyValues > 0);
    }

    /**
     * Parse a key-value.
     * key_value -> key ':' value ;
     * @return Node
     */
    private Node keyValue() {
        Node key = key();
        Node value = value();
        return new KeyValueNode(key, value);
    }

    /**
     * Parse a key.
     * key -> number | string ;
     * @return Node
     */
    private Node key() {
        Node node = null;
        if (this.lookahead.token == Token.NUMBER) {
            node = number();
        } else if (this.lookahead.token == Token.STRING) {
            node = string();
        } else {
            //throw new ParserException("Unexpected symbol "+lookahead.sequence+" found");
        }
        return node;
    }

    /**
     * Parse a value.
     * value -> number | string | array_value | dictionary ;
     * @return Node
     */
    private Node value() {
        Node node = null;
        switch (this.lookahead.token) {
            case Token.NUMBER:
                node = number();
                break;
            case Token.STRING:
                node = string();
                break;
            case Token.LIST:
                node = arrayValue();
                break;
            case Token.DICTIONARY:
                node = dictionary();
                break;
            default:
                //throw new ParserException("Unexpected symbol "+lookahead.sequence+" found");
                break;
        }
        return node;
    }

    /**
     * Parse a number.
     * NUMBER
     * @return
     */
    private Node number() {
        Node node = null;
        if (this.lookahead.token == Token.NUMBER) {
            node = new NumberNode(this.lookahead.sequence);
            nextToken();
        }
        return node;
    }

    /**
     * Parse a String.
     * STRING
     * @return
     */
    private Node string() {
        Node node = null;
        if (this.lookahead.token == Token.STRING) {
            node = new StringNode(this.lookahead.sequence);
            nextToken();
        }
        return node;
    }

}
