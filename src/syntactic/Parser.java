package syntactic;

import java.util.Arrays;
import java.util.LinkedList;

import lexic.Token;
import lexic.Tokenizer;

/**
 * Class that will be used to perform the syntactic analysis of the binary JSON file.
 * This class will use the tokens generated by the tokenization and create the abstract tree. 
 * 
 * This class uses the naming set of rules defined by the description of the project.
 * 
 * The grammar used to parse the entries is the following:
 * 
 * 
 * 
 * 	dictionary : array_key_value ;
 * 
 * 	array_key_value : key_value | array_key_value;
 * 
 * 	key_value : key ':' value ;
 * 
 * 	key : NUMBER | STRING ;
 * 
 * 	value : NUMBER | STRING | array_value | dictionary ;
 * 
 * 	array_value : value | value ',' array_value ;
 * 
 * 
 * 
 * @author danilo.melo.rocha
 *
 */
public class Parser {
	
	private LinkedList<Token> tokens;
    private Token lookahead;

    public Parser(String input) {
        byte[] b = input.getBytes();

        Tokenizer tokenizer = new Tokenizer();
        tokenizer.tokenize(b);

        this.tokens = (LinkedList<Token>) tokenizer.getTokens().clone();
        this.lookahead = this.tokens.getFirst();

        attemptParsing();
    }

    /**
     * The function that will attempt to parse the input String.
     * Usually, a JSON file is a collection, but regarding to the input samples, this function
     * will also accept int, String and list as JSON binary.
     */
    private void attemptParsing() {
        int[] typesToAttemptParsing = { Token.DICTIONARY, Token.LIST, Token.STRING, Token.NUMBER };
        while (typesToAttemptParsing.length != 0) {
            switch (typesToAttemptParsing[0]) {
                case Token.NUMBER:
                    number();
                    if (this.lookahead.token == Token.EPSILON) {
                        System.out.println("Successfully parsed an int.");
                    }
                    break;
                case Token.STRING:
                    string();
                    if (this.lookahead.token == Token.EPSILON) {
                        System.out.println("Successfully parsed a string.");
                    }
                    break;
                case Token.LIST:
                    arrayValue();
                    if (this.lookahead.token == Token.EPSILON) {
                        System.out.println("Successfully parsed an array.");
                    }
                    break;
                case Token.DICTIONARY:
                    dictionary();
                    if (this.lookahead.token == Token.EPSILON) {
                        System.out.println("Successfully parsed a JSON Dictionary.");
                    }
                    break;
                default:
                    break;
            }
            typesToAttemptParsing = Arrays.copyOfRange(typesToAttemptParsing, 1, typesToAttemptParsing.length);
            if (this.lookahead.token == Token.EPSILON) {
                break;
            }
        }
        if (this.lookahead.token != Token.EPSILON) {
            System.out.println("Failed parsing.");
        }
    }

    /**
     * Consumes the token that is being identified by the parsed.
     */
    private void nextToken() {
        tokens.pop();
        // at the end of input we return an epsilon token
        if (tokens.isEmpty()) {
            lookahead = new Token(Token.EPSILON, ""/*, -1*/);
        } else {
            lookahead = tokens.getFirst();
        }
    }

    /**
     * Parse the dictionary/JSON file.
     * dictionary -> array_key_value;
     */
    private void dictionary() {
        if (this.lookahead.token == Token.DICTIONARY) {
            nextToken();
            arrayKeyValue();
        } else {
            // EPSILON
        }
    }

    /**
     * Parse a list of values.
     * // array_value -> value | value ',' array_value ;
     */
    private void arrayValue() {
        if (this.lookahead.token == Token.LIST) {
            nextToken();
            // the current token is the amount of values
            int amountOfValues = new Integer(this.lookahead.sequence);
            nextToken();
            do {
                value();
                amountOfValues--;
            } while(amountOfValues > 0);
        }
    }

    /**
     * Iterate through a list of key-value child to a dictionary.
     * array_key_value -> key_value | array_key_value;
     */
    private void arrayKeyValue() {
        // the current token is the amount of key values
        int amountOfKeyValues = new Integer(this.lookahead.sequence);
        nextToken();
        do {
            keyValue();
            amountOfKeyValues--;
        } while(amountOfKeyValues > 0);
    }

    /**
     * Parse a key-value.
     * key_value -> key ':' value ;
     */
    private void keyValue() {
        key();
        value();
    }

    /**
     * Parse a key.
     * key -> number | string ;
     */
    private void key() {
        if (this.lookahead.token == Token.NUMBER) {
            number();
        } else if (this.lookahead.token == Token.STRING) {
            string();
        } else {
            //throw new ParserException("Unexpected symbol "+lookahead.sequence+" found");
        }
    }

    /**
     * Parse a value.
     * value -> number | string | array_value | dictionary ;
     */
    private void value() {
        switch (this.lookahead.token) {
            case Token.NUMBER:
                number();
                break;
            case Token.STRING:
                string();
                break;
            case Token.LIST:
                arrayValue();
                break;
            case Token.DICTIONARY:
                dictionary();
                break;
            default:
                //throw new ParserException("Unexpected symbol "+lookahead.sequence+" found");
                break;
        }
    }

    /**
     * Parse a number.
     * NUMBER
     */
    private void number() {
        if (this.lookahead.token == Token.NUMBER) {
            nextToken();
        }
    }

    /**
     * Parse a String.
     * STRING
     */
    private void string() {
        if (this.lookahead.token == Token.STRING) {
            nextToken();
        }
    }

}
